"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signerToTrustSmartAccount = exports.TRUST_ADDRESSES = void 0;
const viem_1 = require("viem");
const actions_1 = require("viem/actions");
const getAccountNonce_1 = require("../../actions/public/getAccountNonce.js");
const toSmartAccount_1 = require("../toSmartAccount.js");
const types_1 = require("../types.js");
const isSmartAccountDeployed_1 = require("../../utils/isSmartAccountDeployed.js");
const encodeCallData_1 = require("./utils/encodeCallData.js");
const getAccountAddress_1 = require("./utils/getAccountAddress.js");
const getDummySignature_1 = require("./utils/getDummySignature.js");
const getFactoryData_1 = require("./utils/getFactoryData.js");
const signTransaction_1 = require("./utils/signTransaction.js");
const signUserOperation_1 = require("./utils/signUserOperation.js");
async function _signTypedData(signer, chainId, accountAddress, hashedMessage) {
    return signer.signTypedData({
        domain: {
            chainId: Number(chainId),
            name: "Barz",
            verifyingContract: accountAddress,
            version: "v0.2.0"
        },
        types: {
            BarzMessage: [{ name: "message", type: "bytes" }]
        },
        message: {
            message: hashedMessage
        },
        primaryType: "BarzMessage"
    });
}
exports.TRUST_ADDRESSES = {
    secp256k1VerificationFacetAddress: "0x81b9E3689390C7e74cF526594A105Dea21a8cdD5",
    factoryAddress: "0x729c310186a57833f622630a16d13f710b83272a"
};
async function signerToTrustSmartAccount(client, { signer, factoryAddress = exports.TRUST_ADDRESSES.factoryAddress, entryPoint: entryPointAddress, index = 0n, secp256k1VerificationFacetAddress = exports.TRUST_ADDRESSES.secp256k1VerificationFacetAddress, address, nonceKey }) {
    const viemSigner = {
        ...signer,
        signTransaction: (_, __) => {
            throw new types_1.SignTransactionNotSupportedBySmartAccount();
        }
    };
    const [accountAddress, chainId] = await Promise.all([
        address ??
            (0, getAccountAddress_1.getAccountAddress)(client, {
                factoryAddress,
                secp256k1VerificationFacetAddress,
                entryPoint: entryPointAddress,
                bytes: viemSigner.publicKey,
                index
            }),
        client.chain?.id ?? (0, actions_1.getChainId)(client)
    ]);
    if (!accountAddress)
        throw new Error("Account address not found");
    let smartAccountDeployed = await (0, isSmartAccountDeployed_1.isSmartAccountDeployed)(client, accountAddress);
    return (0, toSmartAccount_1.toSmartAccount)({
        address: accountAddress,
        client: client,
        publicKey: accountAddress,
        entryPoint: entryPointAddress,
        source: "TrustSmartAccount",
        signMessage: ({ message }) => {
            return _signTypedData(signer, chainId, accountAddress, (0, viem_1.hashMessage)(message));
        },
        signTransaction: signTransaction_1.signTransaction,
        signTypedData(typedData) {
            return _signTypedData(signer, chainId, accountAddress, (0, viem_1.hashTypedData)(typedData));
        },
        getNonce: async (key) => {
            return (0, getAccountNonce_1.getAccountNonce)(client, {
                sender: accountAddress,
                entryPoint: entryPointAddress,
                key: key ?? nonceKey
            });
        },
        signUserOperation: async (userOperation) => {
            return (0, signUserOperation_1.signUserOperation)(client, {
                account: viemSigner,
                userOperation,
                entryPoint: entryPointAddress,
                chainId: chainId
            });
        },
        getInitCode: async () => {
            smartAccountDeployed =
                smartAccountDeployed ||
                    (await (0, isSmartAccountDeployed_1.isSmartAccountDeployed)(client, accountAddress));
            if (smartAccountDeployed) {
                return "0x";
            }
            return (0, viem_1.concatHex)([
                factoryAddress,
                await (0, getFactoryData_1.getFactoryData)({
                    bytes: viemSigner.publicKey,
                    secp256k1VerificationFacetAddress,
                    index
                })
            ]);
        },
        async getFactory() {
            smartAccountDeployed =
                smartAccountDeployed ||
                    (await (0, isSmartAccountDeployed_1.isSmartAccountDeployed)(client, accountAddress));
            if (smartAccountDeployed)
                return undefined;
            return factoryAddress;
        },
        async getFactoryData() {
            smartAccountDeployed =
                smartAccountDeployed ||
                    (await (0, isSmartAccountDeployed_1.isSmartAccountDeployed)(client, accountAddress));
            if (smartAccountDeployed)
                return undefined;
            return (0, getFactoryData_1.getFactoryData)({
                bytes: viemSigner.publicKey,
                secp256k1VerificationFacetAddress,
                index
            });
        },
        async encodeDeployCallData(_) {
            throw new Error("Trust account doesn't support account deployment");
        },
        async encodeCallData(args) {
            return (0, encodeCallData_1.encodeCallData)({ args });
        },
        async getDummySignature(userOperation) {
            return (0, getDummySignature_1.getDummySignature)(userOperation);
        }
    });
}
exports.signerToTrustSmartAccount = signerToTrustSmartAccount;
//# sourceMappingURL=signerToTrustSmartAccount.js.map