import { concatHex, hashMessage, hashTypedData } from "viem";
import { getChainId } from "viem/actions";
import { getAccountNonce } from "../../actions/public/getAccountNonce.js";
import { toSmartAccount } from "../toSmartAccount.js";
import { SignTransactionNotSupportedBySmartAccount } from "../types.js";
import { isSmartAccountDeployed } from "../../utils/isSmartAccountDeployed.js";
import { encodeCallData } from "./utils/encodeCallData.js";
import { getAccountAddress } from "./utils/getAccountAddress.js";
import { getDummySignature } from "./utils/getDummySignature.js";
import { getFactoryData } from "./utils/getFactoryData.js";
import { signTransaction } from "./utils/signTransaction.js";
import { signUserOperation } from "./utils/signUserOperation.js";
async function _signTypedData(signer, chainId, accountAddress, hashedMessage) {
    return signer.signTypedData({
        domain: {
            chainId: Number(chainId),
            name: "Barz",
            verifyingContract: accountAddress,
            version: "v0.2.0"
        },
        types: {
            BarzMessage: [{ name: "message", type: "bytes" }]
        },
        message: {
            message: hashedMessage
        },
        primaryType: "BarzMessage"
    });
}
/**
 * Default addresses for Trust Smart Account
 */
export const TRUST_ADDRESSES = {
    secp256k1VerificationFacetAddress: "0x81b9E3689390C7e74cF526594A105Dea21a8cdD5",
    factoryAddress: "0x729c310186a57833f622630a16d13f710b83272a"
};
/**
 * @description Creates an Trust Smart Account from a private key.
 *
 * @returns A Private Key Trust Smart Account.
 */
export async function signerToTrustSmartAccount(client, { signer, factoryAddress = TRUST_ADDRESSES.factoryAddress, entryPoint: entryPointAddress, index = 0n, secp256k1VerificationFacetAddress = TRUST_ADDRESSES.secp256k1VerificationFacetAddress, address, nonceKey }) {
    const viemSigner = {
        ...signer,
        signTransaction: (_, __) => {
            throw new SignTransactionNotSupportedBySmartAccount();
        }
    };
    const [accountAddress, chainId] = await Promise.all([
        address ??
            getAccountAddress(client, {
                factoryAddress,
                secp256k1VerificationFacetAddress,
                entryPoint: entryPointAddress,
                bytes: viemSigner.publicKey,
                index
            }),
        client.chain?.id ?? getChainId(client)
    ]);
    if (!accountAddress)
        throw new Error("Account address not found");
    let smartAccountDeployed = await isSmartAccountDeployed(client, accountAddress);
    return toSmartAccount({
        address: accountAddress,
        client: client,
        publicKey: accountAddress,
        entryPoint: entryPointAddress,
        source: "TrustSmartAccount",
        signMessage: ({ message }) => {
            return _signTypedData(signer, chainId, accountAddress, hashMessage(message));
        },
        signTransaction: signTransaction,
        signTypedData(typedData) {
            return _signTypedData(signer, chainId, accountAddress, hashTypedData(typedData));
        },
        getNonce: async (key) => {
            return getAccountNonce(client, {
                sender: accountAddress,
                entryPoint: entryPointAddress,
                key: key ?? nonceKey
            });
        },
        signUserOperation: async (userOperation) => {
            return signUserOperation(client, {
                account: viemSigner,
                userOperation,
                entryPoint: entryPointAddress,
                chainId: chainId
            });
        },
        getInitCode: async () => {
            smartAccountDeployed =
                smartAccountDeployed ||
                    (await isSmartAccountDeployed(client, accountAddress));
            if (smartAccountDeployed) {
                return "0x";
            }
            return concatHex([
                factoryAddress,
                await getFactoryData({
                    bytes: viemSigner.publicKey,
                    secp256k1VerificationFacetAddress,
                    index
                })
            ]);
        },
        async getFactory() {
            smartAccountDeployed =
                smartAccountDeployed ||
                    (await isSmartAccountDeployed(client, accountAddress));
            if (smartAccountDeployed)
                return undefined;
            return factoryAddress;
        },
        async getFactoryData() {
            smartAccountDeployed =
                smartAccountDeployed ||
                    (await isSmartAccountDeployed(client, accountAddress));
            if (smartAccountDeployed)
                return undefined;
            return getFactoryData({
                bytes: viemSigner.publicKey,
                secp256k1VerificationFacetAddress,
                index
            });
        },
        async encodeDeployCallData(_) {
            throw new Error("Trust account doesn't support account deployment");
        },
        async encodeCallData(args) {
            return encodeCallData({ args });
        },
        async getDummySignature(userOperation) {
            return getDummySignature(userOperation);
        }
    });
}
//# sourceMappingURL=signerToTrustSmartAccount.js.map