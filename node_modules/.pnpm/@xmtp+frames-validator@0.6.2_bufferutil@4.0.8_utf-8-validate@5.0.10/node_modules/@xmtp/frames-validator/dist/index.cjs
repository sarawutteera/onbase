'use strict';

var proto = require('@xmtp/proto');
var utils = require('@noble/curves/abstract/utils');
var secp256k1 = require('@noble/curves/secp256k1');
var sha256 = require('@noble/hashes/sha256');
var utils$1 = require('viem/utils');

// hexToBytes implementation that is compatible with `xmtp-js`'s implementation
function hexToBytes(s) {
    if (s.startsWith("0x")) {
        s = s.slice(2);
    }
    const bytes = new Uint8Array(s.length / 2);
    for (let i = 0; i < bytes.length; i++) {
        const j = i * 2;
        bytes[i] = Number.parseInt(s.slice(j, j + 2), 16);
    }
    return bytes;
}
// Ensure the signature is valid
function ecdsaCheck(sig) {
    if (sig.bytes.length !== 64) {
        throw new Error(`invalid signature length: ${sig.bytes.length}`);
    }
    if (sig.recovery !== 0 && sig.recovery !== 1) {
        throw new Error(`invalid recovery bit: ${sig.recovery}`);
    }
}
// Get the signature bytes from a Signature proto message, whether it is wallet signed or signed by
// an XMTP key
function extractSignature(signature) {
    if (signature.ecdsaCompact?.bytes) {
        ecdsaCheck(signature.ecdsaCompact);
        return signature.ecdsaCompact;
    }
    else if (signature.walletEcdsaCompact?.bytes) {
        ecdsaCheck(signature.walletEcdsaCompact);
        return signature.walletEcdsaCompact;
    }
    else {
        throw new Error("invalid signature");
    }
}
// Directly copied from `xmtp-js`
function walletSignatureText(keyBytes) {
    return ("XMTP : Create Identity\n" +
        `${utils.bytesToHex(keyBytes)}\n` +
        "\n" +
        "For more info: https://xmtp.org/signatures/");
}
// Ensure that the `SignedPublicKeyBundle` has the required fields
function validateSignedPublicKeyBundle(bundle) {
    if (!bundle.identityKey?.keyBytes) {
        return false;
    }
    if (!bundle.preKey?.keyBytes) {
        return false;
    }
    return true;
}
/**
 * Validate that a message was signed by the identity key in a `SignedPublicKeyBundle`
 * @param message Uint8array
 * @param sig signature.Signature
 * @param bundle publicKey.SignedPublicKeyBundle
 */
function verifyIdentityKeySignature(message, sig, bundle) {
    if (!validateSignedPublicKeyBundle(bundle)) {
        throw new Error("Invalid public key bundle");
    }
    if (!sig.ecdsaCompact?.bytes) {
        throw new Error("Missing ECDSA compact");
    }
    const pubKey = proto.publicKey.UnsignedPublicKey.decode(bundle.identityKey.keyBytes);
    if (!pubKey.secp256k1Uncompressed?.bytes) {
        throw new Error("Missing key bytes");
    }
    const digest = sha256.sha256(message);
    const isVerified = secp256k1.secp256k1.verify(sig.ecdsaCompact.bytes, digest, pubKey.secp256k1Uncompressed.bytes);
    if (!isVerified) {
        throw new Error("Invalid signature");
    }
}
function computeAddress(bytes) {
    const publicKey = utils$1.bytesToHex(bytes.slice(1));
    const hash = utils$1.keccak256(publicKey);
    const address = hash.substring(hash.length - 40);
    return utils$1.getAddress(`0x${address}`);
}
function recoverWalletAddress(messageString, sig) {
    const digest = hexToBytes(utils$1.hashMessage(messageString));
    const pubKey = secp256k1.secp256k1.Signature.fromCompact(sig.bytes)
        .addRecoveryBit(sig.recovery)
        .recoverPublicKey(digest)
        .toRawBytes(false);
    return computeAddress(pubKey);
}
/**
 * Retrieve the wallet address from a `SignedPublicKeyBundle` proto
 * @param publicKeyBundle
 * @returns string wallet address
 */
function verifyWalletSignature(publicKeyBundle) {
    if (!validateSignedPublicKeyBundle(publicKeyBundle)) {
        throw new Error("Invalid public key bundle");
    }
    const toVerify = extractSignature(publicKeyBundle.identityKey.signature);
    const signatureText = walletSignatureText(publicKeyBundle.identityKey.keyBytes);
    const walletAddress = recoverWalletAddress(signatureText, toVerify);
    if (!walletAddress) {
        throw new Error("Could not recover wallet address");
    }
    return walletAddress;
}

const { b64Decode } = proto.fetcher;
async function validateFramesPost(data) {
    const { untrustedData, trustedData } = data;
    const { walletAddress } = untrustedData;
    const { messageBytes: messageBytesString } = trustedData;
    const messageBytes = b64Decode(messageBytesString);
    const { actionBody, actionBodyBytes, signature, signedPublicKeyBundle } = deserializeProtoMessage(messageBytes);
    const verifiedWalletAddress = await getVerifiedWalletAddress(actionBodyBytes, signature, signedPublicKeyBundle);
    if (verifiedWalletAddress !== walletAddress) {
        console.log(`${verifiedWalletAddress} !== ${walletAddress}`);
        throw new Error("Invalid wallet address");
    }
    await checkUntrustedData(untrustedData, actionBody);
    return {
        actionBody,
        verifiedWalletAddress,
    };
}
function deserializeProtoMessage(messageBytes) {
    const frameAction = proto.frames.FrameAction.decode(messageBytes);
    if (!frameAction.signature || !frameAction.signedPublicKeyBundle) {
        throw new Error("Invalid frame action: missing signature or signed public key bundle");
    }
    const actionBody = proto.frames.FrameActionBody.decode(frameAction.actionBody);
    return {
        actionBody,
        actionBodyBytes: frameAction.actionBody,
        signature: frameAction.signature,
        signedPublicKeyBundle: frameAction.signedPublicKeyBundle,
    };
}
async function getVerifiedWalletAddress(actionBodyBytes, signature, signedPublicKeyBundle) {
    const walletAddress = verifyWalletSignature(signedPublicKeyBundle);
    verifyIdentityKeySignature(actionBodyBytes, signature, signedPublicKeyBundle);
    return walletAddress;
}
async function checkUntrustedData({ url, buttonIndex, opaqueConversationIdentifier, timestamp, state = "", inputText = "", }, actionBody) {
    if (actionBody.frameUrl !== url) {
        throw new Error("Mismatched URL");
    }
    if (actionBody.buttonIndex !== buttonIndex) {
        throw new Error("Mismatched button index");
    }
    if (actionBody.opaqueConversationIdentifier !== opaqueConversationIdentifier) {
        throw new Error("Mismatched conversation identifier");
    }
    if (actionBody.timestamp.toNumber() !== timestamp) {
        throw new Error("Mismatched timestamp");
    }
    if (actionBody.state !== state) {
        throw new Error("Mismatched state");
    }
    if (actionBody.inputText !== inputText) {
        throw new Error("Missing input text");
    }
}

class XmtpValidator {
    constructor() {
        this.protocolIdentifier = "xmtp";
        this.minProtocolVersionDate = "2024-02-09";
    }
    minProtocolVersion() {
        return `${this.protocolIdentifier}@${this.minProtocolVersionDate}`;
    }
    isSupported(payload) {
        if (!payload.clientProtocol) {
            return false;
        }
        const [protocol, version] = payload.clientProtocol.split("@");
        if (!protocol || !version) {
            return false;
        }
        const isCorrectClientProtocol = protocol === "xmtp";
        const isCorrectVersion = version >= this.minProtocolVersionDate;
        const isTrustedDataValid = typeof payload.trustedData?.messageBytes === "string";
        return isCorrectClientProtocol && isCorrectVersion && isTrustedDataValid;
    }
    async validate(payload) {
        try {
            const validationResponse = await validateFramesPost(payload);
            return {
                isValid: true,
                clientProtocol: payload.clientProtocol,
                message: validationResponse,
            };
        }
        catch (error) {
            return {
                isValid: false,
            };
        }
    }
}

exports.XmtpValidator = XmtpValidator;
exports.deserializeProtoMessage = deserializeProtoMessage;
exports.validateFramesPost = validateFramesPost;
//# sourceMappingURL=index.cjs.map
