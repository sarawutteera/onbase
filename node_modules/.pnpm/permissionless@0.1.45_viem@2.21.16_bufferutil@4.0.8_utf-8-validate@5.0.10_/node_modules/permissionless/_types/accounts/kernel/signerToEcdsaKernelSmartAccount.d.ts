import type { PublicActions, PublicRpcSchema } from "viem";
import { type Address, type Chain, type Client, type Transport } from "viem";
import type { EntryPoint, Prettify } from "../../types";
import type { ENTRYPOINT_ADDRESS_V06_TYPE } from "../../types/entrypoint";
import type { SmartAccount } from "../types";
import { type SmartAccountSigner } from "../types";
export type KernelEcdsaSmartAccount<entryPoint extends EntryPoint, transport extends Transport = Transport, chain extends Chain | undefined = Chain | undefined> = SmartAccount<entryPoint, "kernelEcdsaSmartAccount", transport, chain>;
export type KernelVersion<entryPoint extends EntryPoint> = entryPoint extends ENTRYPOINT_ADDRESS_V06_TYPE ? "0.2.1" | "0.2.2" | "0.2.3" | "0.2.4" : "0.3.0-beta" | "0.3.1";
/**
 * Default addresses map for different kernel smart account versions
 */
export declare const KERNEL_VERSION_TO_ADDRESSES_MAP: {
    [key in KernelVersion<EntryPoint>]: {
        ECDSA_VALIDATOR: Address;
        ACCOUNT_LOGIC: Address;
        FACTORY_ADDRESS: Address;
        META_FACTORY_ADDRESS?: Address;
    };
};
export declare const getEcdsaRootIdentifierForKernelV3: (validatorAddress: Address) => `0x${string}`;
export type SignerToEcdsaKernelSmartAccountParameters<entryPoint extends EntryPoint, TSource extends string = string, TAddress extends Address = Address> = Prettify<{
    signer: SmartAccountSigner<TSource, TAddress>;
    version?: KernelVersion<entryPoint>;
    entryPoint: entryPoint;
    address?: Address;
    index?: bigint;
    factoryAddress?: Address;
    metaFactoryAddress?: Address;
    accountLogicAddress?: Address;
    ecdsaValidatorAddress?: Address;
    nonceKey?: bigint;
}>;
/**
 * Build a kernel smart account from a private key, that use the ECDSA signer behind the scene
 * @param client
 * @param privateKey
 * @param entryPoint
 * @param index
 * @param factoryAddress
 * @param accountLogicAddress
 * @param ecdsaValidatorAddress
 */
export declare function signerToEcdsaKernelSmartAccount<entryPoint extends EntryPoint, TTransport extends Transport = Transport, TChain extends Chain | undefined = Chain | undefined, TSource extends string = string, TAddress extends Address = Address>(client: Client<TTransport, TChain, undefined, PublicRpcSchema, PublicActions<TTransport, TChain>>, { signer, address, version, entryPoint: entryPointAddress, index, factoryAddress: _factoryAddress, metaFactoryAddress: _metaFactoryAddress, accountLogicAddress: _accountLogicAddress, ecdsaValidatorAddress: _ecdsaValidatorAddress, nonceKey }: SignerToEcdsaKernelSmartAccountParameters<entryPoint, TSource, TAddress>): Promise<KernelEcdsaSmartAccount<entryPoint, TTransport, TChain>>;
//# sourceMappingURL=signerToEcdsaKernelSmartAccount.d.ts.map